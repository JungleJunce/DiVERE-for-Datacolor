# 进程隔离功能使用指南

## 概述

DiVERE 从 2025-11 版本开始引入了**进程隔离**功能，用于优化内存管理，特别是在 macOS 系统上长时间处理大量图片时的内存占用问题。

### 什么是进程隔离？

进程隔离功能会为每张图片的预览处理创建一个独立的 worker 进程。当切换到下一张图片时，旧进程会被完全销毁，所有占用的内存都会归还给操作系统，从而避免内存无限增长。

### 优势

- ✅ **内存释放更彻底**：切换图片时，旧进程的所有内存 100% 归还给系统
- ✅ **长时间稳定**：处理 100+ 张图片时，内存占用保持稳定
- ✅ **崩溃隔离**：预览处理崩溃不会影响主程序
- ✅ **无需调参**：自动管理，无需手动设置清理参数

### 潜在影响

- ⚠️ **切换延迟**：切换图片时可能有 200-500ms 的延迟（首次预览时创建新进程）
- ⚠️ **额外资源**：每个进程会占用一定的系统资源

---

## 配置方式

进程隔离功能通过 **配置文件** 控制，配置项位于 `config/app_settings.json`。

### 配置文件设置（唯一配置方式）

编辑 `config/app_settings.json` 文件：

```json
{
  "ui": {
    "use_process_isolation": "never"  // 配置值：never | always | auto
  }
}
```

配置值说明：
- **`never`**：禁用进程隔离，使用传统线程模式
- **`always`**：强制启用进程隔离
- **`auto`**：根据操作系统自动决定（macOS/Linux 启用，Windows 禁用）

修改配置后，需要重启应用才能生效。

---

## 配置值详细说明

| 配置值 | 行为 | 适用场景 |
|--------|------|---------|
| `never` | 禁用进程隔离（默认） | 日常使用、稳定性优先 |
| `always` | 强制启用进程隔离 | 内存占用问题严重时 |
| `auto` | 根据平台自动决定 | macOS/Linux 启用，Windows 禁用 |

---

## 默认行为

如果不修改 `config/app_settings.json`，DiVERE 使用默认值 **`never`**：

- **所有平台**：进程隔离**禁用**

如需启用进程隔离，请手动修改配置文件：
```json
{
  "ui": {
    "use_process_isolation": "always"  // 或 "auto"
  }
}
```

> 📝 **注意**：当前版本（2025-11）默认禁用进程隔离。在稳定性验证后，未来版本可能将默认改为 `auto`（macOS/Linux 自动启用）。

---

## 自动回退机制

进程隔离功能具有完善的错误处理和自动回退机制：

1. **启动失败回退**：如果 worker 进程启动失败，自动回退到传统线程模式
2. **崩溃自动恢复**：worker 进程崩溃后，会自动重启（最多尝试 3 次）
3. **超时检测**：如果预览请求超过 5 秒未响应，会记录警告
4. **资源清理**：程序退出时自动清理所有 worker 进程和共享内存

---

## 性能对比

### 内存占用测试（10 次图片切换）

| 模式 | 总内存增长 | 平均每次增长 |
|------|-----------|------------|
| 传统线程模式 | ~500-800 MB | ~50-80 MB |
| 进程隔离模式 | ~130 MB | ~13 MB |

### 切换延迟测试

| 操作 | 传统模式 | 进程隔离模式 | 差异 |
|------|---------|------------|------|
| 切换图片并首次预览 | ~50-100 ms | ~200-500 ms | +150-400 ms |
| 后续预览（同一图片） | ~50-100 ms | ~50-100 ms | 无差异 |

---

## 常见问题

### Q1: 我应该启用进程隔离吗？

**建议启用**，如果你：
- 使用 macOS 或 Linux 系统
- 需要长时间处理大量图片（50+ 张）
- 计算机内存有限（8GB 或更少）
- 发现内存占用随使用时间持续增长

**可以不启用**，如果你：
- 使用 Windows 系统（可能有兼容性问题）
- 每次只处理少量图片（10 张以内）
- 计算机内存充足（16GB 或更多）
- 对切换图片的响应速度非常敏感

### Q2: 进程隔离会影响色卡优化功能吗？

**不会**。色卡优化功能在主进程中运行，不受进程隔离影响。进程隔离只影响预览处理。

### Q3: 进程隔离会影响导出功能吗？

**不会**。导出功能在主进程的线程池中运行，不受进程隔离影响。切换图片时，导出任务会继续正常执行。

### Q4: 如果遇到问题怎么办？

1. **禁用进程隔离**：修改 `config/app_settings.json`：
   ```json
   {
     "ui": {
       "use_process_isolation": "never"
     }
   }
   ```
2. **查看日志**：检查应用日志，搜索 "Worker process" 相关的错误信息
3. **报告问题**：在 GitHub Issues 中报告问题，包括：
   - 操作系统和版本
   - Python 版本
   - 错误日志
   - 复现步骤
   - `config/app_settings.json` 中的配置

### Q5: 如何验证进程隔离是否已启用？

启动 DiVERE 后，查看日志输出或状态栏提示，应该会显示"进程隔离已启用"或类似信息。如果启用失败，会显示"已回退到线程模式"的提示。

你也可以通过系统监视器（Activity Monitor / Task Manager）查看进程：
- 如果启用：会看到多个 `python` 进程（主进程 + worker 进程）
- 如果禁用：只有一个主进程

---

## 技术细节

### 工作原理

```
┌────────────────────────────────────┐
│ 主进程 (DiVERE UI)                  │
│ ├─ 加载图片 A                       │
│ ├─ 创建 Worker 进程 A               │
│ │  └─ 处理预览请求（独立内存空间）   │
│ │                                   │
│ ├─ 切换到图片 B                     │
│ │  ├─ 销毁 Worker 进程 A ✓          │
│ │  │  └─ 内存 100% 归还给 OS        │
│ │  └─ 创建 Worker 进程 B            │
│ │     └─ 从干净状态开始             │
└────────────────────────────────────┘
```

### 通信机制

- **Proxy 图片**：通过 `multiprocessing.shared_memory` 共享（避免拷贝大数组）
- **参数**：通过 `multiprocessing.Queue` 序列化传递（每次预览）
- **结果**：通过 `shared_memory` 返回（避免拷贝大数组）

### 资源管理

- **进程生命周期**：与图片绑定（lazy creation）
- **内存清理**：进程退出时，操作系统强制回收所有 heap 内存
- **崩溃恢复**：最多自动重启 3 次
- **泄漏检测**：追踪所有 shared memory，确保清理

---

## 参考文档

- **技术方案**：`PROCESS_ISOLATION_PROPOSAL.md` - 详细的技术设计和实施计划
- **内存分析**：`PROCESS_ISOLATION_ANALYSIS.md` - 内存问题分析和解决方案对比
- **测试报告**：`tests/test_process_isolation.py` - 自动化测试脚本和结果

---

## 版本历史

- **2025-11-16**：首次发布进程隔离功能（Phase 1-3 完成）
  - 基础架构实现
  - 异常处理和自动恢复
  - 全面测试验证
  - 配置方式：仅使用 `config/app_settings.json`（移除环境变量控制）

---

**文档版本**：2.0
**创建日期**：2025-11-16
**最后更新**：2025-11-16
**配置方式**：仅通过 `config/app_settings.json` 控制，无外部环境变量依赖
